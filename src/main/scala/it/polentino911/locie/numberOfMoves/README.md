### Problem description

[See here](./instructions.html) for detailed explanation.

### Solution

This was an interesting graph traversal problem:

* first you need to build a graph representation of your board;
* then you need to recursively walk across all the possible connected nodes, picking up however only the one with
  minimum distance from the end node;
    * note though that if the distance is <=3, I stop doing that optimization and let the algo traverse all child
      nodes (once you get very close to the final point, you need to try by brute force all child nodes because it may
      be optimal to actually move backwards, sideways or past the final node, in order to reach it,
      see [Reducing the actual board](#reducing-the-actual-board))
* check whether we arrived to the end node, and:
    * if we did, compare the length of the path with the global `min` variable & update it if needed
    * if didn't ensure we are not entering into an infinite loop, otherwise recurse

However, the interesting bit of this exercise was that it ran on Scala 2.13, which
meant [parallel collections were removed from std library, into a separate project](https://github.com/scala/scala-parallel-collections)
; no dirty and cheap `.par()`
exploitation.

#### Reducing the actual board

This, combined with 100x100+ sized boards, made the solution exceeded the 7 seconds time limit imposed by HackerRank.
Therefore I had to reduce the actual board or better, to frame it, in order to keep out the parts of the board that for
sure won't yield a minimum solution.

If, for example, we have a `10x10` board, and we want to go from `(5,3)` to `(8, 9)`:

|  \  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|  0  |  x  |  x  |  x  |  x  |  x  |  x  |  x  |  x  |  x  |  x  |
|  1  |  x  |  x  |  x  |  x  |  x  |  x  |  x  |  x  |  x  |  x  |
|  2  |  x  |  x  |  x  |  x  |  x  |  x  |  x  |  x  |  x  |  x  |
|  3  |  x  |     |     |     |     |     |     |     |     |     |
|  4  |  x  |     |     |     |     |     |     |     |     |     |
|  5  |  x  |     |     |  S  |     |     |     |     |     |     |
|  6  |  x  |     |     |     |     |     |     |     |     |     |
|  7  |  x  |     |     |     |     |     |     |     |     |     |
|  8  |  x  |     |     |     |     |     |     |     |     |  E  |
|  9  |  x  |     |     |     |     |     |     |     |     |     |

you'll notice that all the positions marked with an `x` can be removed, thus the entire board reduced from `10x10`
into `7x9`. Hence the reason of the convenience `Frame` class.

Why those extra margins on around the nodes? Well, suppose you got a `5x5` grid, and want to go from
`(2,2)` to `(1,3)`:

|  \  |  0  |  1  |  2  |  3  |  4  |
|:---:|:---:|:---:|:---:|:---:|:---:|
|  0  |     |  .  |     |     |     |
|  1  |     |     |     |  E  |     |
|  2  |     |     |  S  |     |     |
|  3  |     |     |     |     |  .  |
|  4  |     |     |     |     |     |

you can either follow one of those min paths:

* `(2,2)` -> `(0,1)` -> `(1,3)`
* `(2,2)` -> `(3,4)` -> `(1,3)`

which means the frame must at least exceed one extra row/column. But in the
particular [example shown in HR](./number_of_moves_example.svg), you can notice that the extra columns to be taken into
account are 2, so in the end the frame must have `+2` rows/columns compared to the rectangle generated by Start and End.
You can quickly prove that more than 2 extra rows/columns won't yield any extra benefit in finding optimal solutions.

Note: I just noticed that I could've sped up the graph generation a bit by combining the filtering at lines `97`
and `100` in one single pass. Oh well, the algo still worked under the time limit :)
